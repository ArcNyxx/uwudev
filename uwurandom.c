#include <linux/uaccess.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/random.h>
#include <linux/string.h>
#include <linux/device.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/fs.h>

MODULE_LICENSE("Dual MIT/GPL");
MODULE_DESCRIPTION("urandom but better");
MODULE_AUTHOR("valadaptive");
MODULE_VERSION("0.1");

static ssize_t dev_read(struct file *, char *, size_t, loff_t *);
static int     dev_open(struct inode *, struct file *);
static int     dev_release(struct inode *, struct file *);

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .read = dev_read,
    .open = dev_open,
    .release = dev_release
};

static int major;
static struct class* dev_class;
static dev_t dev_num;

// maximum markov chain size
#define MARKOV_MAX 2

typedef struct uwu_markov_state uwu_markov_state;

typedef char (*markov_func)(struct uwu_markov_state* state);

// Stores the state for a Markov chain operation.
struct uwu_markov_state {
    char prev[MARKOV_MAX]; /* previous character */
    size_t remaining_chars; /* number of remaining characters */
    markov_func func;
};

// Stores the state for a "print string" operation.
typedef struct {
    char* string; /* pointer to string */
} uwu_print_string_state;

// Stores the state for a "repeat this character" operation.
typedef struct {
    char character;
    size_t remaining_chars; /* number of remaining times to repeat the character */
} uwu_repeat_character_state;

// Because we're asked to read a certain amount of data at a time, and we
// can't control what that amount is, we need a way to store what we're
// currently doing. This is done using opcodes--currently "repeat character",
// "print string", and the most complicated one, "print using Markov chain".
// An op is executed repeatedly as many times as we need characters.
// Once it's run out of characters, move on to the next one.
// If we're all out of ops, generate a new program.

typedef union {
    uwu_markov_state markov;
    uwu_print_string_state print_string;
    uwu_repeat_character_state repeat_character;
} uwu_op_state;

typedef enum {
    UWU_NULL,
    UWU_MARKOV,
    UWU_PRINT_STRING,
    UWU_REPEAT_CHARACTER
} UWU_OPCODE;

typedef struct {
    UWU_OPCODE opcode;
    uwu_op_state state;
    void* op_data;
} uwu_op;

#define MAX_OPS 4

typedef struct {
    uwu_op ops[MAX_OPS];
    size_t current_op;
    int prev_op;
} uwu_state;

/**
 * Lots of autogenerated Markov chain code
 * TODO: move to a separate file once my makefile decides to stop hating me
 */

static char
catnonsense_next_token(char prev_tokens[]) {
    unsigned int random = 0;
    get_random_bytes(&random, sizeof(random));

    switch ((prev_tokens[0] << 8) | (prev_tokens[1] << 0)) {
        case 0x0602: // mr
            random %= 30;
            if (random < 9) return 0; // a
            if (random < 13) return 6; // r
            if (random < 14) return 8; // w
            if (random < 15) return 1; // e
            return 4; // o
        case 0x0006: // ra
            return 4; // o
        case 0x0400: // ao
            return 8; // w
        case 0x0804: // ow
            random %= 38;
            if (random < 22) return 2; // m
            if (random < 26) return 3; // n
            if (random < 27) return 8; // w
            if (random < 37) return 6; // r
            return 5; // p
        case 0x0208: // wm
            random %= 30;
            if (random < 17) return 6; // r
            return 1; // e
        case 0x0102: // me
            random %= 20;
            if (random < 8) return 8; // w
            return 4; // o
        case 0x0801: // ew
            random %= 8;
            if (random < 6) return 2; // m
            if (random < 7) return 3; // n
            return 5; // p
        case 0x0606: // rr
            random %= 14;
            if (random < 1) return 5; // p
            if (random < 8) return 6; // r
            if (random < 11) return 2; // m
            return 4; // o
        case 0x0506: // rp
            return 5; // p
        case 0x0505: // pp
            return 7; // u
        case 0x0705: // pu
            return 6; // r
        case 0x0607: // ur
            return 6; // r
        case 0x0206: // rm
            random %= 10;
            if (random < 5) return 6; // r
            return 1; // e
        case 0x0308: // wn
            return 9; // y
        case 0x0903: // ny
            return 0; // a
        case 0x0009: // ya
            random %= 6;
            if (random < 1) return 3; // n
            if (random < 2) return 2; // m
            return 0; // a
        case 0x0300: // an
            return 9; // y
        case 0x0200: // am
            random %= 4;
            if (random < 3) return 6; // r
            return 1; // e
        case 0x0808: // ww
            random %= 4;
            if (random < 3) return 8; // w
            return 2; // m
        case 0x0806: // rw
            return 2; // m
        case 0x0106: // re
            return 4; // o
        case 0x0401: // eo
            return 8; // w
        case 0x0406: // ro
            return 8; // w
        case 0x0608: // wr
            random %= 10;
            if (random < 7) return 2; // m
            return 3; // n
        case 0x0508: // wp
            return 7; // u
        case 0x0000: // aa
            random %= 9;
            if (random < 6) return 0; // a
            return 2; // m
        case 0x0306: // rn
            return 9; // y
        default:
            return -1;
    }
}

static char
catnonsense_markov(uwu_markov_state* state) {
    static const char tokens[] = {'a' ,'e' ,'m' ,'n' ,'o' ,'p' ,'r' ,'u' ,'w' ,'y'};

    if (state->remaining_chars == 0) {
        return 0;
    }

    char next_token = catnonsense_next_token(state->prev);
    char end_token = state->prev[1];
    state->prev[1] = state->prev[0];
    state->prev[0] = next_token;
    state->remaining_chars--;
    if (next_token == -1) {
        state->remaining_chars = 0;
    }

    return tokens[(int) end_token];
}


static char
keysmash_next_token(char prev_tokens[]) {
    unsigned int random = 0;
    get_random_bytes(&random, sizeof(random));

    switch ((prev_tokens[0] << 0)) {
        case 0x01: // a
            random %= 30;
            if (random < 3) return 11; // l
            if (random < 5) return 6; // g
            if (random < 7) return 3; // d
            if (random < 13) return 9; // j
            if (random < 18) return 5; // f
            if (random < 25) return 7; // h
            if (random < 26) return 0; // ;
            if (random < 29) return 16; // u
            return 14; // r
        case 0x0b: // l
            random %= 11;
            if (random < 4) return 10; // k
            if (random < 6) return 0; // ;
            if (random < 7) return 15; // s
            if (random < 8) return 6; // g
            if (random < 9) return 5; // f
            if (random < 10) return 3; // d
            return 1; // a
        case 0x0a: // k
            random %= 20;
            if (random < 1) return 15; // s
            if (random < 2) return 3; // d
            if (random < 6) return 5; // f
            if (random < 12) return 1; // a
            if (random < 13) return 11; // l
            if (random < 16) return 6; // g
            if (random < 19) return 9; // j
            return 7; // h
        case 0x0f: // s
            random %= 4;
            if (random < 2) return 3; // d
            return 10; // k
        case 0x03: // d
            random %= 17;
            if (random < 5) return 7; // h
            if (random < 6) return 15; // s
            if (random < 13) return 5; // f
            if (random < 14) return 6; // g
            if (random < 15) return 10; // k
            if (random < 16) return 9; // j
            return 2; // b
        case 0x07: // h
            random %= 31;
            if (random < 3) return 5; // f
            if (random < 10) return 6; // g
            if (random < 13) return 10; // k
            if (random < 17) return 9; // j
            if (random < 20) return 1; // a
            if (random < 23) return 3; // d
            if (random < 25) return 8; // i
            if (random < 27) return 14; // r
            if (random < 28) return 0; // ;
            if (random < 29) return 12; // n
            if (random < 30) return 7; // h
            return 16; // u
        case 0x05: // f
            random %= 26;
            if (random < 2) return 11; // l
            if (random < 14) return 6; // g
            if (random < 16) return 7; // h
            if (random < 17) return 1; // a
            if (random < 21) return 10; // k
            if (random < 23) return 3; // d
            return 9; // j
        case 0x00: // ;
            random %= 8;
            if (random < 4) return 1; // a
            if (random < 5) return 10; // k
            if (random < 6) return 3; // d
            if (random < 7) return 11; // l
            return 7; // h
        case 0x06: // g
            random %= 34;
            if (random < 4) return 0; // ;
            if (random < 8) return 9; // j
            if (random < 16) return 1; // a
            if (random < 17) return 3; // d
            if (random < 19) return 2; // b
            if (random < 25) return 7; // h
            if (random < 26) return 15; // s
            if (random < 29) return 11; // l
            if (random < 31) return 5; // f
            if (random < 32) return 10; // k
            if (random < 33) return 16; // u
            return 12; // n
        case 0x09: // j
            random %= 22;
            if (random < 3) return 10; // k
            if (random < 6) return 5; // f
            if (random < 11) return 7; // h
            if (random < 15) return 3; // d
            if (random < 17) return 1; // a
            if (random < 18) return 14; // r
            if (random < 19) return 4; // e
            if (random < 20) return 13; // o
            if (random < 21) return 11; // l
            return 6; // g
        case 0x02: // b
            random %= 3;
            if (random < 1) return 10; // k
            if (random < 2) return 1; // a
            return 7; // h
        case 0x10: // u
            random %= 7;
            if (random < 3) return 14; // r
            if (random < 4) return 1; // a
            if (random < 5) return 5; // f
            if (random < 6) return 9; // j
            return 4; // e
        case 0x0e: // r
            random %= 6;
            if (random < 3) return 6; // g
            if (random < 5) return 1; // a
            return 7; // h
        case 0x08: // i
            return 16; // u
        case 0x0c: // n
            random %= 2;
            if (random < 1) return 6; // g
            return 7; // h
        case 0x04: // e
            return 6; // g
        case 0x0d: // o
            return 6; // g
        default:
            return -1;
    }
}

static char
keysmash_markov(uwu_markov_state* state) {
    static const char tokens[] = {';' ,'a' ,'b' ,'d' ,'e' ,'f' ,'g' ,'h' ,'i' ,'j' ,'k' ,'l' ,'n' ,'o' ,'r' ,'s' ,'u'};

    if (state->remaining_chars == 0) {
        return 0;
    }

    char next_token = keysmash_next_token(state->prev);
    char end_token = state->prev[0];

    state->prev[0] = next_token;
    state->remaining_chars--;
    if (next_token == -1) {
        state->remaining_chars = 0;
    }

    return tokens[(int) end_token];
}


static char
scrunkly_next_token(char prev_tokens[]) {
    unsigned int random = 0;
    get_random_bytes(&random, sizeof(random));

    switch ((prev_tokens[0] << 8) | (prev_tokens[1] << 0)) {
        case 0x0b15: // th
            return 8; // e
        case 0x080b: // he
            random %= 1600;
            if (random < 1200) return 0; //  
            if (random < 1400) return 16; // n
            if (random < 1431) return 3; // .
            if (random < 1531) return 15; // m
            if (random < 1563) return 2; // ,
            return 1; // !
        case 0x0008: // e 
            random %= 2500;
            if (random < 300) return 14; // l
            if (random < 900) return 21; // t
            if (random < 1100) return 4; // a
            if (random < 1400) return 6; // c
            if (random < 1800) return 20; // s
            if (random < 2000) return 24; // w
            if (random < 2200) return 5; // b
            if (random < 2400) return 13; // k
            return 15; // m
        case 0x0e00: //  l
            random %= 705;
            if (random < 564) return 12; // i
            return 17; // o
        case 0x0c0e: // li
            random %= 600;
            if (random < 300) return 21; // t
            if (random < 400) return 13; // k
            if (random < 500) return 23; // v
            return 15; // m
        case 0x150c: // it
            random %= 1000;
            if (random < 300) return 21; // t
            if (random < 406) return 3; // .
            if (random < 706) return 0; //  
            if (random < 806) return 25; // y
            if (random < 905) return 2; // ,
            return 1; // !
        case 0x1515: // tt
            return 14; // l
        case 0x0e15: // tl
            return 8; // e
        case 0x080e: // le
            random %= 1200;
            if (random < 1100) return 0; //  
            if (random < 1128) return 2; // ,
            if (random < 1166) return 1; // !
            return 3; // .
        case 0x1500: //  t
            random %= 1912;
            if (random < 364) return 12; // i
            if (random < 764) return 17; // o
            if (random < 864) return 4; // a
            return 11; // h
        case 0x0c15: // ti
            return 8; // e
        case 0x080c: // ie
            random %= 500;
            if (random < 400) return 16; // n
            if (random < 421) return 1; // !
            if (random < 464) return 3; // .
            return 2; // ,
        case 0x1008: // en
            random %= 600;
            if (random < 400) return 18; // p
            if (random < 431) return 2; // ,
            if (random < 531) return 0; //  
            if (random < 567) return 3; // .
            return 1; // !
        case 0x1210: // np
            return 20; // s
        case 0x1412: // ps
            return 25; // y
        case 0x1914: // sy
            random %= 400;
            if (random < 24) return 1; // !
            if (random < 324) return 0; //  
            if (random < 365) return 3; // .
            return 2; // ,
        case 0x0119: // y!
            random %= 203;
            if (random < 145) return 1; // !
            return 0; //  
        case 0x0101: // !!
            random %= 1200;
            if (random < 580) return 1; // !
            return 0; //  
        case 0x0001: // ! 
            random %= 849;
            if (random < 128) return 20; // s
            if (random < 264) return 4; // a
            if (random < 454) return 21; // t
            if (random < 485) return 16; // n
            if (random < 523) return 25; // y
            if (random < 641) return 14; // l
            if (random < 715) return 6; // c
            if (random < 753) return 11; // h
            if (random < 786) return 5; // b
            if (random < 814) return 12; // i
            return 24; // w
        case 0x1400: //  s
            random %= 1271;
            if (random < 265) return 17; // o
            if (random < 800) return 6; // c
            if (random < 1100) return 18; // p
            if (random < 1171) return 11; // h
            return 15; // m
        case 0x1114: // so
            random %= 300;
            if (random < 200) return 0; //  
            return 17; // o
        case 0x0011: // o 
            random %= 500;
            if (random < 100) return 4; // a
            if (random < 200) return 12; // i
            if (random < 300) return 14; // l
            if (random < 400) return 5; // b
            return 15; // m
        case 0x0400: //  a
            random %= 1067;
            if (random < 200) return 7; // d
            if (random < 700) return 16; // n
            return 24; // w
        case 0x0704: // ad
            return 17; // o
        case 0x1107: // do
            random %= 500;
            if (random < 200) return 19; // r
            if (random < 300) return 22; // u
            return 17; // o
        case 0x1311: // or
            return 16; // n
        case 0x1013: // rn
            return 4; // a
        case 0x0410: // na
            return 14; // l
        case 0x0e04: // al
            return 8; // e
        case 0x1004: // an
            random %= 600;
            if (random < 500) return 7; // d
            return 0; //  
        case 0x0710: // nd
            return 0; //  
        case 0x0007: // d 
            random %= 500;
            if (random < 200) return 6; // c
            if (random < 300) return 7; // d
            if (random < 400) return 12; // i
            return 20; // s
        case 0x0600: //  c
            random %= 735;
            if (random < 300) return 22; // u
            if (random < 500) return 4; // a
            return 19; // r
        case 0x1606: // cu
            return 21; // t
        case 0x1516: // ut
            return 8; // e
        case 0x0815: // te
            random %= 300;
            if (random < 200) return 20; // s
            if (random < 233) return 3; // .
            if (random < 262) return 2; // ,
            return 1; // !
        case 0x1408: // es
            return 21; // t
        case 0x1514: // st
            return 0; //  
        case 0x0015: // t 
            random %= 600;
            if (random < 200) return 21; // t
            if (random < 300) return 6; // c
            if (random < 500) return 4; // a
            return 20; // s
        case 0x1115: // to
            random %= 400;
            if (random < 300) return 17; // o
            return 0; //  
        case 0x1111: // oo
            random %= 900;
            if (random < 300) return 21; // t
            if (random < 365) return 1; // !
            if (random < 441) return 3; // .
            if (random < 641) return 13; // k
            if (random < 741) return 17; // o
            if (random < 841) return 0; //  
            return 2; // ,
        case 0x1511: // ot
            return 20; // s
        case 0x1415: // ts
            return 12; // i
        case 0x0c14: // si
            random %= 300;
            if (random < 200) return 21; // t
            return 8; // e
        case 0x0315: // t.
            random %= 144;
            if (random < 43) return 0; //  
            return 3; // .
        case 0x0003: // . 
            random %= 843;
            if (random < 131) return 4; // a
            if (random < 164) return 11; // h
            if (random < 225) return 6; // c
            if (random < 447) return 21; // t
            if (random < 481) return 5; // b
            if (random < 624) return 20; // s
            if (random < 664) return 24; // w
            if (random < 751) return 14; // l
            if (random < 782) return 16; // n
            if (random < 818) return 12; // i
            return 25; // y
        case 0x1804: // aw
            random %= 500;
            if (random < 300) return 24; // w
            if (random < 330) return 3; // .
            if (random < 430) return 0; //  
            if (random < 473) return 1; // !
            return 2; // ,
        case 0x1818: // ww
            random %= 500;
            if (random < 200) return 24; // w
            return 0; //  
        case 0x0018: // w 
            random %= 600;
            if (random < 100) return 14; // l
            if (random < 200) return 20; // s
            if (random < 400) return 21; // t
            if (random < 500) return 24; // w
            return 12; // i
        case 0x0d0c: // ik
            return 8; // e
        case 0x080d: // ke
            return 0; //  
        case 0x0700: //  d
            return 17; // o
        case 0x1611: // ou
            return 5; // b
        case 0x0516: // ub
            return 14; // l
        case 0x0e05: // bl
            random %= 300;
            if (random < 100) return 8; // e
            return 17; // o
        case 0x0415: // ta
            return 18; // p
        case 0x1204: // ap
            random %= 200;
            if (random < 100) return 0; //  
            return 18; // p
        case 0x0012: // p 
            return 16; // n
        case 0x1000: //  n
            random %= 162;
            if (random < 100) return 17; // o
            return 0; //  
        case 0x1110: // no
            return 24; // w
        case 0x1811: // ow
            random %= 300;
            if (random < 200) return 0; //  
            return 15; // m
        case 0x0c00: //  i
            random %= 364;
            if (random < 200) return 21; // t
            if (random < 300) return 6; // c
            if (random < 315) return 3; // .
            if (random < 339) return 1; // !
            return 2; // ,
        case 0x0406: // ca
            random %= 300;
            if (random < 100) return 16; // n
            if (random < 200) return 15; // m
            return 21; // t
        case 0x0010: // n 
            random %= 300;
            if (random < 200) return 21; // t
            return 9; // f
        case 0x170c: // iv
            return 8; // e
        case 0x0817: // ve
            return 0; //  
        case 0x0308: // e.
            random %= 202;
            if (random < 160) return 3; // .
            return 0; //  
        case 0x0303: // ..
            random %= 1271;
            if (random < 633) return 3; // .
            return 0; //  
        case 0x0b00: //  h
            return 4; // a
        case 0x040b: // ha
            return 18; // p
        case 0x1212: // pp
            return 25; // y
        case 0x1912: // py
            random %= 200;
            if (random < 100) return 0; //  
            if (random < 123) return 3; // .
            if (random < 164) return 1; // !
            return 2; // ,
        case 0x0019: // y 
            random %= 1000;
            if (random < 100) return 13; // k
            if (random < 300) return 21; // t
            if (random < 500) return 20; // s
            if (random < 700) return 7; // d
            if (random < 800) return 24; // w
            return 4; // a
        case 0x0d00: //  k
            random %= 300;
            if (random < 100) return 7; // d
            return 12; // i
        case 0x070d: // kd
            return 5; // b
        case 0x0507: // db
            random %= 100;
            if (random < 36) return 3; // .
            if (random < 69) return 1; // !
            return 2; // ,
        case 0x0305: // b.
            random %= 36;
            if (random < 28) return 3; // .
            return 0; //  
        case 0x0614: // sc
            return 19; // r
        case 0x1306: // cr
            random %= 900;
            if (random < 500) return 22; // u
            return 12; // i
        case 0x1613: // ru
            return 16; // n
        case 0x1016: // un
            random %= 800;
            if (random < 400) return 13; // k
            if (random < 700) return 10; // g
            return 9; // f
        case 0x0d10: // nk
            random %= 1100;
            if (random < 700) return 14; // l
            if (random < 900) return 25; // y
            if (random < 1000) return 22; // u
            return 17; // o
        case 0x0e0d: // kl
            random %= 700;
            if (random < 600) return 25; // y
            return 8; // e
        case 0x190e: // ly
            random %= 500;
            if (random < 73) return 1; // !
            if (random < 373) return 0; //  
            if (random < 439) return 3; // .
            return 2; // ,
        case 0x1800: //  w
            random %= 475;
            if (random < 275) return 11; // h
            return 12; // i
        case 0x0b18: // wh
            return 8; // e
        case 0x0210: // n,
            return 2; // ,
        case 0x0202: // ,,
            random %= 1585;
            if (random < 188) return 21; // t
            if (random < 965) return 2; // ,
            if (random < 1030) return 6; // c
            if (random < 1066) return 12; // i
            if (random < 1095) return 11; // h
            if (random < 1224) return 20; // s
            if (random < 1319) return 14; // l
            if (random < 1452) return 4; // a
            if (random < 1477) return 24; // w
            if (random < 1515) return 16; // n
            if (random < 1552) return 25; // y
            return 5; // b
        case 0x1502: // ,t
            random %= 188;
            if (random < 152) return 11; // h
            return 12; // i
        case 0x0500: //  b
            return 17; // o
        case 0x1105: // bo
            return 12; // i
        case 0x0c11: // oi
            return 16; // n
        case 0x100c: // in
            random %= 700;
            if (random < 600) return 13; // k
            return 10; // g
        case 0x190d: // ky
            return 0; //  
        case 0x1214: // sp
            random %= 300;
            if (random < 200) return 22; // u
            return 19; // r
        case 0x1612: // pu
            return 16; // n
        case 0x0a10: // ng
            random %= 400;
            if (random < 200) return 8; // e
            return 14; // l
        case 0x080a: // ge
            random %= 200;
            if (random < 61) return 3; // .
            if (random < 126) return 2; // ,
            return 1; // !
        case 0x0c13: // ri
            random %= 400;
            if (random < 200) return 16; // n
            return 15; // m
        case 0x0111: // o!
            random %= 136;
            if (random < 105) return 1; // !
            return 0; //  
        case 0x0b14: // sh
            return 19; // r
        case 0x130b: // hr
            return 17; // o
        case 0x1113: // ro
            random %= 200;
            if (random < 100) return 16; // n
            return 12; // i
        case 0x1011: // on
            return 13; // k
        case 0x0f0c: // im
            random %= 400;
            if (random < 200) return 5; // b
            return 21; // t
        case 0x050f: // mb
            return 14; // l
        case 0x110e: // lo
            random %= 400;
            if (random < 38) return 1; // !
            if (random < 138) return 0; //  
            if (random < 338) return 17; // o
            if (random < 364) return 3; // .
            return 2; // ,
        case 0x150f: // mt
            random %= 300;
            if (random < 100) return 14; // l
            if (random < 138) return 3; // .
            if (random < 238) return 25; // y
            if (random < 273) return 2; // ,
            return 1; // !
        case 0x0108: // e!
            random %= 208;
            if (random < 157) return 1; // !
            return 0; //  
        case 0x0c18: // wi
            return 7; // d
        case 0x070c: // id
            return 7; // d
        case 0x0707: // dd
            return 14; // l
        case 0x0e07: // dl
            return 8; // e
        case 0x160d: // ku
            return 20; // s
        case 0x1416: // us
            random %= 100;
            if (random < 34) return 3; // .
            if (random < 67) return 1; // !
            return 2; // ,
        case 0x0314: // s.
            random %= 34;
            if (random < 26) return 3; // .
            return 0; //  
        case 0x0208: // e,
            return 2; // ,
        case 0x0602: // ,c
            return 19; // r
        case 0x0311: // o.
            random %= 141;
            if (random < 37) return 0; //  
            return 3; // .
        case 0x0319: // y.
            random %= 195;
            if (random < 153) return 3; // .
            return 0; //  
        case 0x0f08: // em
            return 0; //  
        case 0x000f: // m 
            return 21; // t
        case 0x0c0d: // ki
            random %= 400;
            if (random < 300) return 21; // t
            return 15; // m
        case 0x1915: // ty
            random %= 200;
            if (random < 31) return 1; // !
            if (random < 131) return 0; //  
            if (random < 162) return 3; // .
            return 2; // ,
        case 0x0900: //  f
            return 14; // l
        case 0x0e09: // fl
            return 22; // u
        case 0x160e: // lu
            return 16; // n
        case 0x0910: // nf
            return 0; //  
        case 0x0009: // f 
            return 4; // a
        case 0x0215: // t,
            return 2; // ,
        case 0x0c02: // ,i
            random %= 36;
            if (random < 14) return 1; // !
            if (random < 26) return 2; // ,
            return 3; // .
        case 0x010c: // i!
            random %= 38;
            if (random < 25) return 1; // !
            return 0; //  
        case 0x1900: //  y
            return 4; // a
        case 0x0419: // ya
            return 25; // y
        case 0x1904: // ay
            random %= 100;
            if (random < 34) return 1; // !
            if (random < 66) return 2; // ,
            return 3; // .
        case 0x0d11: // ok
            return 12; // i
        case 0x0318: // w.
            random %= 30;
            if (random < 24) return 3; // .
            return 0; //  
        case 0x0e0a: // gl
            return 8; // e
        case 0x110d: // ko
            random %= 100;
            if (random < 33) return 1; // !
            if (random < 72) return 3; // .
            return 2; // ,
        case 0x060c: // ic
            return 4; // a
        case 0x0f04: // am
            return 21; // t
        case 0x1504: // at
            return 0; //  
        case 0x0f00: //  m
            random %= 200;
            if (random < 100) return 12; // i
            return 8; // e
        case 0x0c0f: // mi
            return 18; // p
        case 0x120c: // ip
            return 25; // y
        case 0x080f: // me
            return 17; // o
        case 0x1108: // eo
            return 24; // w
        case 0x0f18: // wm
            return 8; // e
        case 0x0f14: // sm
            return 17; // o
        case 0x110f: // mo
            return 14; // l
        case 0x0e11: // ol
            return 0; //  
        case 0x000e: // l 
            return 20; // s
        case 0x1312: // pr
            return 17; // o
        case 0x0115: // t!
            random %= 122;
            if (random < 85) return 1; // !
            return 0; //  
        case 0x0b02: // ,h
            return 4; // a
        case 0x0211: // o,
            return 2; // ,
        case 0x1402: // ,s
            random %= 129;
            if (random < 29) return 11; // h
            if (random < 64) return 17; // o
            return 6; // c
        case 0x030c: // i.
            random %= 25;
            if (random < 17) return 3; // .
            return 0; //  
        case 0x0219: // y,
            return 2; // ,
        case 0x0e02: // ,l
            random %= 95;
            if (random < 59) return 17; // o
            return 12; // i
        case 0x0118: // w!
            random %= 43;
            if (random < 24) return 1; // !
            return 0; //  
        case 0x0105: // b!
            random %= 33;
            if (random < 29) return 1; // !
            return 0; //  
        case 0x0310: // n.
            random %= 36;
            if (random < 25) return 3; // .
            return 0; //  
        case 0x0402: // ,a
            return 24; // w
        case 0x0114: // s!
            random %= 33;
            if (random < 24) return 1; // !
            return 0; //  
        case 0x1802: // ,w
            return 11; // h
        case 0x1002: // ,n
            return 0; //  
        case 0x0218: // w,
            return 2; // ,
        case 0x020c: // i,
            return 2; // ,
        case 0x1902: // ,y
            return 4; // a
        case 0x0214: // s,
            return 2; // ,
        case 0x0502: // ,b
            return 17; // o
        case 0x0205: // b,
            return 2; // ,
        case 0x0110: // n!
            random %= 33;
            if (random < 26) return 1; // !
            return 0; //  
        default:
            return -1;
    }
}

static char
scrunkly_markov(uwu_markov_state* state) {
    static const char tokens[] = {' ' ,'!' ,',' ,'.' ,'a' ,'b' ,'c' ,'d' ,'e' ,'f' ,'g' ,'h' ,'i' ,'k' ,'l' ,'m' ,'n' ,'o' ,'p' ,'r' ,'s' ,'t' ,'u' ,'v' ,'w' ,'y'};

    if (state->remaining_chars == 0) {
        return 0;
    }

    char next_token = scrunkly_next_token(state->prev);
    char end_token = state->prev[1];
    state->prev[1] = state->prev[0];
    state->prev[0] = next_token;
    state->remaining_chars--;
    if (next_token == -1) {
        state->remaining_chars = 0;
    }

    return tokens[(int) end_token];
}

/**
 * End of autogenerated Markov chain code
 */

#define CREATE_PRINT_STRING(printed_string) {\
    .opcode = UWU_PRINT_STRING,\
    .state = {\
        .print_string = {\
            .string = (printed_string)\
        }\
    }\
}

#define CREATE_REPEAT_CHARACTER(repeated_character, num_repetitions) {\
    .opcode = UWU_REPEAT_CHARACTER,\
    .state = {\
        .repeat_character = {\
            .character = (repeated_character),\
            .remaining_chars = (num_repetitions)\
        }\
    }\
}

#define NUM_ACTIONS 12

static char *actions[NUM_ACTIONS] = {
    "*tilts head*",
    "*twitches ears slightly*",
    "*purrs*",
    "*falls asleep*",
    "*sits on ur keyboard*",
    "*nuzzles*",
    "*stares at u*",
    "*points towards case of monster zero ultra*",
    "*sneezes*",
    "*plays with yarn*",
    "*eats all ur doritos*",
    "*lies down on a random surface*"
};

// Pick a random program from the list of programs and write it to the ops list
static void
generate_new_ops(uwu_state* state) {
    // init to 0 in case get_random_bytes fails
    unsigned int random = 0;
    get_random_bytes(&random, sizeof(random));

    static uwu_op null_op = {
        .opcode = UWU_NULL
    };

    static const int NUM_OPS = 10;

    if (state->prev_op == -1) {
        random %= NUM_OPS;
    } else {
        // don't repeat previous op
        random %= NUM_OPS - 1;
        if (random >= state->prev_op) {
            random += 1;
        }
    }

    state->prev_op = random;

    uwu_op* ops = state->ops;
    switch (random) {
        case 0: { // uwu
            uwu_op op = CREATE_PRINT_STRING("uwu");
            ops[0] = op;
            ops[1] = null_op;
            break;
        }
        case 1: { // catgirl nonsense
            get_random_bytes(&random, sizeof(random));
            uwu_op op1 = {
                .opcode = UWU_MARKOV,
                .state = {
                    .markov = {
                        .prev = {6, 2},
                        .remaining_chars = (random % 125) + 25,
                        .func = &catnonsense_markov
                    }
                }
            };
            uwu_op op2 = CREATE_PRINT_STRING("nya");
            ops[0] = op1;
            ops[1] = op2;
            ops[2] = null_op;
            break;
        }
        case 2: { // nyaaaaaaa
            get_random_bytes(&random, sizeof(random));
            uwu_op op1 = CREATE_PRINT_STRING("ny");
            uwu_op op2 = CREATE_REPEAT_CHARACTER('a', (random % 7) + 1);
            ops[0] = op1;
            ops[1] = op2;
            ops[2] = null_op;
            break;
        }
        case 3: { // >/////<
            get_random_bytes(&random, sizeof(random));
            uwu_op op1 = CREATE_PRINT_STRING(">");
            uwu_op op2 = CREATE_REPEAT_CHARACTER('/', (random % 4) + 3);
            uwu_op op3 = CREATE_PRINT_STRING("<");
            ops[0] = op1;
            ops[1] = op2;
            ops[2] = op3;
            ops[3] = null_op;
            break;
        }
        case 4: { // :3
            uwu_op op = CREATE_PRINT_STRING(":3");
            ops[0] = op;
            ops[1] = null_op;
            break;
        }
        case 5: { // actions
            get_random_bytes(&random, sizeof(random));
            uwu_op op = CREATE_PRINT_STRING(actions[random % NUM_ACTIONS]);
            ops[0] = op;
            ops[1] = null_op;
            break;
        }
        case 6: { // keyboard mash
            get_random_bytes(&random, sizeof(random));
            uwu_op op = {
                .opcode = UWU_MARKOV,
                .state = {
                    .markov = {
                        .prev = {random % 17},
                        .remaining_chars = (random % 125) + 25,
                        .func = &keysmash_markov
                    }
                }
            };
            ops[0] = op;
            ops[1] = null_op;
            break;
        }
        case 7: { // screaming
            get_random_bytes(&random, sizeof(random));
            uwu_op op = CREATE_REPEAT_CHARACTER('A', (random % 12) + 5);
            ops[0] = op;
            ops[1] = null_op;
            break;
        }
        case 8: { // aww the scrunkly :)
            get_random_bytes(&random, sizeof(random));
            uwu_op op = {
                .opcode = UWU_MARKOV,
                .state = {
                    .markov = {
                        .prev = {24, 4},
                        .remaining_chars = (random % 75) + 25,
                        .func = &scrunkly_markov
                    }
                }
            };
            ops[0] = op;
            ops[1] = null_op;
            break;
        }
        case 9: { // owo
            uwu_op op = CREATE_PRINT_STRING("owo");
            ops[0] = op;
            ops[1] = null_op;
            break;
        }
    }
}

// Execute an operation once
// TODO: buffer for better performance
static char exec_op(uwu_op* op) {
    switch (op->opcode) {
        case UWU_PRINT_STRING: {
            char character = *(op->state.print_string.string);
            op->state.print_string.string++;
            return character;
        }

        case UWU_MARKOV: {
            char (*markov_fn)(uwu_markov_state*);

            markov_fn = op->state.markov.func;
            return markov_fn(&op->state.markov);
        }

        case UWU_REPEAT_CHARACTER: {
            if (op->state.repeat_character.remaining_chars == 0) {
                return 0;
            }
            op->state.repeat_character.remaining_chars--;
            return op->state.repeat_character.character;
        }

        default:
            return 0;
    }
}

// Keep going, advancing and generating ops as needed, until we get a valid next
// character, then return it.
static char get_next_character(uwu_state* state) {
    while (true) {
        uwu_op* current_op = &state->ops[state->current_op];
        if (current_op->opcode == UWU_NULL) {
            // regenerate ops
            generate_new_ops(state);
            state->current_op = 0;
            return ' ';
        }

        char character = exec_op(current_op);

        if (character == 0) {
            state->current_op++;
            if (state->current_op >= MAX_OPS) {
                // regenerate ops
                generate_new_ops(state);
                state->current_op = 0;
            }
        } else {
            return character;
        }
    }
}

static ssize_t
dev_read(struct file *fp, char *buf, size_t n, loff_t *of) {
    uwu_state* state = fp->private_data;

    char character = get_next_character(state);

    // TODO: copy more at a time?
    if (copy_to_user(buf, &character, 1))
        return -EFAULT;

    return 1;
}

static int
dev_open(struct inode *ino, struct file *fp) {
    size_t len = sizeof(uwu_state);

    uwu_state *data = kmalloc(len, GFP_KERNEL);

    if (data == NULL) {
        return -ENOMEM;
    }

    data->prev_op = -1;
    data->current_op = 0;
    generate_new_ops(data);

    fp->private_data = data;

    return 0;
}

static int
dev_release(struct inode *ino, struct file *fp) {
    kfree(fp->private_data);
    fp->private_data = NULL;
    return 0;
}

// Make sure all users can thoroughly enjoy /dev/uwurandom
static int
dev_uevent(struct device* dev, struct kobj_uevent_env* env) {
    int result = add_uevent_var(env, "DEVMODE=%#o", 0666);
    if (IS_ERR(result)) {
        return result;
    }
    return 0;
}

static void
kexit(void) {
    device_destroy(dev_class, dev_num);
    class_destroy(dev_class);
    unregister_chrdev(major, "uwurandom");
    return;
}

static int
kinit(void) {
    struct device* pDev;

    major = register_chrdev(0, "uwurandom", &fops);

    if (major < 0)
        return major;

    dev_num = MKDEV(major, 0);

    // Create device class and device automatically. So nice!
    dev_class = class_create(THIS_MODULE, "uwurandom");
    if (IS_ERR(dev_class)) {
        unregister_chrdev(major, "uwurandom");
        return PTR_ERR(dev_class);
    }

    dev_class->dev_uevent = dev_uevent;

    pDev = device_create(dev_class, NULL, dev_num, NULL, "uwurandom");
    if (IS_ERR(pDev)) {
        class_destroy(dev_class);
        unregister_chrdev(major, "uwurandom");
        return PTR_ERR(pDev);
    }


    return 0;
}

module_init(kinit);
module_exit(kexit);
